import numpy as np
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import relationship, validates
from flask_login import UserMixin
from sqlalchemy import CheckConstraint
from datetime import datetime as dt

db = SQLAlchemy()


# Inventory = specific product of specific color and size (has its own inventory stock level)
# Inventory Table establishing attributes
class Inventory(db.Model):
    __tablename__ = 'Inventory'
    # product id is a unique integer
    product_id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    # product item_id ties the specific inventoried product to an item that is sold to customers
    item_id = db.Column(db.Integer, db.ForeignKey('MerchItem.item_id', ondelete='CASCADE'))
    # product code is a semi-semantic string used by the club
    product_code = db.Column(db.String(30), nullable=False, unique=True)
    product_stock = db.Column(db.Integer, nullable=False)
    # color and size may not be applicable for certain items
    product_size = db.Column(db.String(3))
    product_color = db.Column(db.String(15))
    # current unit price the inventory item was purchased at from suppliers
    purchase_price = db.Column(db.Integer, nullable=False)
    # image directory (local for now)
    image_dir = db.Column(db.String(50))

    # many inventories to one merchitem relationship
    merchitem_ref = db.relationship('MerchItem', back_populates='inventories')
    inv_ois = db.relationship('OrderItem', back_populates='inv_ref', uselist=True)
    purchases = db.relationship('InvPurchase', back_populates='purchase_ref', uselist=True)

    def __init__(self, item_id, product_code, product_stock, product_size, product_color, purchase_price, image_dir):
        self.item_id = item_id
        self.product_code = product_code
        self.product_stock = product_stock
        self.product_size = product_size
        self.product_color = product_color
        self.image_dir = image_dir
        self.purchase_price = purchase_price

    def __repr__(self):
        return f"{self.product_code}"


# Merch_Item is the product being sold (traces to specific inventory items of different size/color)
# Merch_Item table
class MerchItem(db.Model):
    __tablename__ = 'MerchItem'
    # autogenerated primary key
    item_id = db.Column(db.Integer, primary_key=True, nullable=False, autoincrement=True)
    # number after the merch/ in the product url
    item_name = db.Column(db.String(50), nullable=False, unique=True)
    # the price at which the product is sold to customers (i.e. small vs large hoodie will sell at same price)
    item_price = db.Column(db.Float, nullable=False)
    # unisex, women's, men's
    item_class = db.Column(db.String(20), nullable=False)
    # for product information accordion
    long_desc = db.Column(db.Text)
    manu_details = db.Column(db.Text)

    # one merchitem to many inventories relationship with cascade deletion rule
    inventories = db.relationship('Inventory', back_populates='merchitem_ref',
                                  uselist=True, cascade='all, delete-orphan')

    def __init__(self, item_name, item_price, item_class, long_desc, manu_details):
        self.item_name = item_name
        self.item_price = item_price
        self.item_class = item_class
        self.long_desc = long_desc
        self.manu_details = manu_details

    def __repr__(self):
        return f'{self.item_name}'


class User(UserMixin, db.Model):
    __tablename__ = "user"

    user_id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(100), nullable=False)
    role = db.Column(db.String(20), nullable=False, default='CUSTOMER')

    def __init__(self, username, password, role='CUSTOMER'):
        self.username = username
        self.password = password
        self.role = role

    # Function for flask_login manager to provider a user ID to know who is logged in
    def get_id(self):
        return str(self.user_id)
    # Required to interact with Flask-login


# Order represents the purchase a customer makes. Contains summary for all line items and customer info
class Order(db.Model):
    __tablename__ = 'Order'
    # primary key to uniquely identify the order
    order_id = db.Column(db.String(30), unique=True)
    order_num = db.Column(db.Integer, unique=True, autoincrement=True, primary_key=True)
    order_date = db.Column(db.DateTime, nullable=False)
    #Adding user_id as a FK but making it nullable since you dont have to be signed in to make an order
    user_id = db.Column(db.Integer, db.ForeignKey('user.user_id'), nullable=True)
    # customer info
    first_name = db.Column(db.String(30), nullable=False)
    last_name = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(100))
    address = db.Column(db.String(100))
    city = db.Column(db.String(100))
    state = db.Column(db.String(2))
    zipcode = db.Column(db.String(9))
    # more order details
    status = db.Column(db.String(20), default='IN PROGRESS')
    order_total = db.Column(db.Float, nullable=False)

    def __init__(self, order_date, first_name, last_name, email, address,
                 city, state, zipcode, order_total, user_id=None, order_id=None):
        # format order_id in form 'ORD-x' and have x autoincrement
        if order_id is None:
            # Generate the order number based on the latest order
            latest_order = Order.query.order_by(Order.order_num.desc()).first()
            if latest_order:
                last_order_num = latest_order.order_num
                self.order_num = last_order_num + 1
                self.order_id = f'ORD-{self.order_num}'
            else:
                self.order_num = 1
                self.order_id = 'ORD-1'
        else:
            self.order_id = order_id

        self.order_date = order_date
        self.user_id = user_id
        self.first_name = first_name
        self.last_name = last_name
        self.email = email
        self.address = address
        self.city = city
        self.state = state
        self.zipcode = zipcode
        self.order_total = order_total

    # one order to many orderitems relationship with cascade deletion rule
    orderitems = relationship('OrderItem', back_populates='order_ref', uselist=True, cascade='all, delete-orphan')

    def __repr__(self):
        return f'{self.first_name} {self.last_name}\'s order total is {self.order_total} on {self.order_date} '


# OrderItem represents the line item within an order, associates order w/ inventory and merchitem
class OrderItem(db.Model):
    __tablename__ = 'OrderItem'
    # primary key concatenates product_code and order_id
    orderitem_id = db.Column(db.String(30), primary_key=True)
    # foreign key order id, supports backref in order
    order_id = db.Column(db.String(30), db.ForeignKey('Order.order_id', ondelete='CASCADE'), nullable=False)
    # foreign key product code, gets set to null if the inventory item is deleted
    # preserves historical customer orders, inventory item that was part of the order can be read thru the orderiten_id
    product_code = db.Column(db.String(30), db.ForeignKey('Inventory.product_code', ondelete='SET NULL'), nullable=True)
    # number of items within the orderitem
    product_qty = db.Column(db.Integer, nullable=False)
    # item_price is from inventory but gets fixed here for historical purposes
    item_price = db.Column(db.Float, nullable=True)
    line_price = db.Column(db.Float, nullable=True)

    # one inventory to many orderitems relationship
    # special rule: save item_price if the inventory gets changed
    inv_ref = db.relationship('Inventory', back_populates='inv_ois', cascade='all, save-update', passive_deletes=True)
    order_ref = db.relationship('Order', back_populates='orderitems')

    def __init__(self, order_id, product_code, product_qty):
        # orderitem_id is a concat of order_id and product_cde
        self.orderitem_id = f'{order_id}-{product_code}'
        self.order_id = order_id
        self.product_code = product_code
        self.product_qty = product_qty
        # defer item price and line_price

    def __repr__(self):
        return f'{self.product_qty}x {self.product_code}'


class InvPurchase(db.Model):
    # longitudinal record of inventory purchase from supplier
    __tablename__ = 'InvPurchase'
    # like orderitem, PK purchase_id concatenates product_code and an autoincrement integer
    purchase_id = db.Column(db.String(50), primary_key=True, nullable=True)
    # timestamp the order purchase
    purchase_date = db.Column(db.DateTime, nullable=False)
    # foreign key product code, gets set to null if the inventory item is deleted
    # preserves historical supplier orders, inventory item that was part of the order can be read thru the orderiten_id
    product_code = db.Column(db.String(30), db.ForeignKey('Inventory.product_code', ondelete='SET NULL'), nullable=True)
    # order price (total)
    purchase_price = db.Column(db.Integer, nullable=False)
    # number of items within inventory order
    purchase_qty = db.Column(db.Integer, nullable=False)

    # one inventory to multiple purchases relationship
    # preserve purchases even if inventory is deleted
    purchase_ref = db.relationship('Inventory', back_populates='purchases',
                                   cascade='all, save-update', passive_deletes=True)

    def __init__(self, product_code, purchase_date, purchase_price, purchase_qty, purchase_id=None):
        # purchase_id concatenates the product code with autoincrement number
        if purchase_id is None:
            # Find last purchase for the inventory item
            latest_purchase = (self.query.filter(InvPurchase.purchase_id.like(f'%{product_code}%')).
                               order_by(InvPurchase.purchase_id.desc()).first())
            if latest_purchase:
                last_purchase_id = int(latest_purchase.purchase_id.split('-')[-1])
                num_digits = len(str(last_purchase_id + 1))
                self.purchase_id = f'PCH-{product_code}-{(last_purchase_id + 1):0{num_digits}}'
            else:
                self.purchase_id = f'PCH-{product_code}-1'
        else:
            self.purchase_id = purchase_id
        self.product_code = product_code
        self.purchase_price = purchase_price
        self.purchase_qty = purchase_qty
        self.purchase_date = purchase_date

    def __repr__(self):
        return f'{self.purchase_id} purchased on {self.purchase_date}'



# creating price change database, stores any selling price changes
class merchitem_pricechange(db.Model):
    _tablename__ = 'merchitem_pricechange'
    # table name for merch item
    change_id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    # change id to track changes
    item_id = db.Column(db.Integer, db.ForeignKey('MerchItem.item_id'))
    # item id foreign key from merch item
    item_price = db.Column(db.Float, nullable=False)
    # item price will serve as old price
    price_change = db.Column(db.Integer, nullable=True)
    # price change will be calculated
    new_price = db.Column(db.Float, nullable=False)
    # this new price needs to come from a form
    change_date = db.Column(db.DateTime, nullable=False)

    def __init__(self, item_id, item_price, new_price, change_date, price_change):
        self.price_change = price_change
        self.item_id = item_id
        self.item_price = item_price
        self.new_price = new_price
        self.change_date = change_date

